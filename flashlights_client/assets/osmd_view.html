<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
    />
    <title>OSMD Practice View</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background-color: #f1f3f6;
        overflow: hidden;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      }

      #osmd {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        background-color: #f1f3f6;
        border-radius: 10px;
        box-sizing: border-box;
        padding: 8px;
      }

      #osmd svg {
        width: auto !important;
        height: auto !important;
        max-width: 100% !important;
        max-height: 100% !important;
      }

      #osmd canvas {
        width: auto !important;
        height: auto !important;
        max-width: 100% !important;
        max-height: 100% !important;
      }

      #osmd svg * {
        fill: #000000 !important;
        stroke: #000000 !important;
      }

      #osmd svg text {
        fill: #000000 !important;
      }

      #osmd svg [fill="none"] {
        stroke: #000000 !important;
      }

      #osmd svg [stroke="none"] {
        fill: #000000 !important;
      }

      #osmd svg [style*="#0C7F79"],
      #osmd svg [style*="#0c7f79"],
      #osmd svg [fill="#0C7F79"],
      #osmd svg [fill="#0c7f79"],
      #osmd svg [data-primer-highlight="true"] {
        fill: #0C7F79 !important;
        stroke: #95FFE3 !important;
        filter:
          drop-shadow(0 0 4px rgba(149, 255, 227, 0.75))
          drop-shadow(0 0 9px rgba(111, 255, 211, 0.45));
      }
    </style>
    <script src="opensheetmusicdisplay.min.js"></script>
  </head>
  <body>
    <div id="osmd" class="osmd-auto-width"></div>
    <script>
      let osmd;
      const BASE_ZOOM = 0.9;
      const HIGHLIGHT_COLOR = '#0C7F79';

      function stringifyError(err) {
        if (!err) {
          return 'Unknown error';
        }
        if (typeof err === 'string') {
          return err;
        }
        if (err.stack) {
          return String(err.stack);
        }
        if (err.message) {
          return String(err.message);
        }
        try {
          return JSON.stringify(err);
        } catch (_) {
          return String(err);
        }
      }

      function postToFlutter(message) {
        try {
          const payload = typeof message === 'string' ? message : JSON.stringify(message);
          if (window.FlutterOSMD && window.FlutterOSMD.postMessage) {
            window.FlutterOSMD.postMessage(payload);
          }
        } catch (err) {
          console.error('postToFlutter failed', err);
        }
      }

      function logToFlutter(message) {
        postToFlutter({ type: 'log', message });
      }

      function applyEngravingPreferences() {
        if (!osmd || !osmd.EngravingRules) {
          return;
        }
        const rules = osmd.EngravingRules;
        rules.RenderSingleHorizontalLine = true;
        if (Object.prototype.hasOwnProperty.call(rules, 'RenderSingleHorizontalStaffline')) {
          rules.RenderSingleHorizontalStaffline = true;
        }
        if (Object.prototype.hasOwnProperty.call(rules, 'RenderXMeasuresPerLineAkaSystem')) {
          rules.RenderXMeasuresPerLineAkaSystem = 3;
        }
        if (Object.prototype.hasOwnProperty.call(rules, 'LastSystemMaxScalingFactor')) {
          rules.LastSystemMaxScalingFactor = 1;
        }
        if (rules.PageFormat && typeof rules.PageFormat === 'object') {
          if (Object.prototype.hasOwnProperty.call(rules.PageFormat, 'Width')) {
            rules.PageFormat.Width = 8000;
          }
        }
        if (Object.prototype.hasOwnProperty.call(rules, 'PageWidth')) {
          rules.PageWidth = 8000;
        }
        if (Object.prototype.hasOwnProperty.call(rules, 'PageLeftMargin')) {
          rules.PageLeftMargin = 0;
        }
        if (Object.prototype.hasOwnProperty.call(rules, 'PageRightMargin')) {
          rules.PageRightMargin = 0;
        }
        if (Object.prototype.hasOwnProperty.call(rules, 'PageTopMargin')) {
          rules.PageTopMargin = 0;
        }
        if (Object.prototype.hasOwnProperty.call(rules, 'PageBottomMargin')) {
          rules.PageBottomMargin = 0;
        }
      }

      function getContentBox(element) {
        try {
          const box = element.getBBox();
          if (
            box &&
            Number.isFinite(box.width) &&
            box.width > 0 &&
            Number.isFinite(box.height) &&
            box.height > 0
          ) {
            return { width: box.width, height: box.height };
          }
        } catch (_) {
          // ignored
        }
        const rect = element.getBoundingClientRect();
        return {
          width: rect?.width && rect.width > 0 ? rect.width : 1200,
          height: rect?.height && rect.height > 0 ? rect.height : 320,
        };
      }

      function makeSvgResponsive(svg, width, height) {
        if (!width || !height) {
          return;
        }
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        svg.removeAttribute('width');
        svg.removeAttribute('height');
        svg.style.width = '100%';
        svg.style.height = 'auto';
        svg.style.maxWidth = '100%';
        svg.style.transform = 'none';
        svg.style.transformOrigin = 'top left';
        svg.style.display = 'block';
      }

      function tintHighlightedStems() {
        const container = document.getElementById('osmd');
        if (!container) {
          return;
        }

        function closestWithClass(node, className) {
          let current = node;
          while (current && current !== container) {
            if (current.classList && current.classList.contains(className)) {
              return current;
            }
            current = current.parentElement;
          }
          return null;
        }

        const highlighted = container.querySelectorAll('[data-primer-highlight="true"]');
        highlighted.forEach((element) => {
          const staveNote = closestWithClass(element, 'vf-stavenote');
          if (!staveNote) {
            return;
          }

          const stemGroups = staveNote.querySelectorAll('.vf-stem, g[class*="vf-stem"]');
          stemGroups.forEach((stemGroup) => {
            stemGroup.setAttribute('data-primer-highlight', 'true');
            stemGroup.querySelectorAll('path, line, polygon, rect').forEach((segment) => {
              applyHighlightColor(segment);
            });
          });
        });
      }

      function applyHighlightColor(segment) {
        const style = segment.getAttribute('style');
        if (style) {
          let updatedStyle = style;
          if (/stroke\s*:/i.test(updatedStyle)) {
            updatedStyle = updatedStyle.replace(/stroke\s*:[^;]+/gi, `stroke:${HIGHLIGHT_COLOR}`);
          } else {
            updatedStyle += `;stroke:${HIGHLIGHT_COLOR}`;
          }
          if (/fill\s*:\s*none/i.test(style)) {
            updatedStyle = updatedStyle.replace(/fill\s*:\s*none/gi, 'fill:none');
          } else if (/fill\s*:/i.test(updatedStyle)) {
            updatedStyle = updatedStyle.replace(/fill\s*:[^;]+/gi, `fill:${HIGHLIGHT_COLOR}`);
          }
          if (updatedStyle !== style) {
            segment.setAttribute('style', updatedStyle);
          }
        }

        segment.setAttribute('stroke', HIGHLIGHT_COLOR);
        const fillAttr = segment.getAttribute('fill');
        if (fillAttr && fillAttr.toLowerCase() !== 'none') {
          segment.setAttribute('fill', HIGHLIGHT_COLOR);
        }
        segment.setAttribute('data-primer-highlight', 'true');
      }

      window.onerror = function(message, source, lineno, colno, error) {
        postToFlutter({ type: 'error', message, source, lineno, colno, detail: error ? stringifyError(error) : null });
      };

      async function initOSMD(message) {
        if (typeof opensheetmusicdisplay === 'undefined') {
          postToFlutter({ type: 'error', phase: 'init', detail: 'opensheetmusicdisplay bundle unavailable' });
          return;
        }
        const xmlString = message && typeof message.xml === 'string' ? message.xml : null;
        if (!xmlString || xmlString.length === 0) {
          postToFlutter({ type: 'error', phase: 'init', detail: 'Missing MusicXML payload' });
          return;
        }
        logToFlutter(`initOSMD: xml length=${xmlString.length}`);
        if (!osmd) {
          try {
            osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay('osmd', {
              backend: 'svg',
              autoResize: false,
              drawTitle: false,
              drawSubtitle: false,
              drawPartNames: false,
              drawingParameters: 'compacttight',
              renderSingleHorizontalLine: true,
              newSystemFromXML: false,
            });
            logToFlutter('OSMD instance created');
          } catch (err) {
            console.error('OSMD ctor failed', err);
            postToFlutter({ type: 'error', phase: 'ctor', detail: stringifyError(err) });
            return;
          }
        }

        try {
          osmd.setOptions({
            renderSingleHorizontalStaffline: true,
            renderSingleHorizontalLine: true,
            drawPartNames: false,
            newSystemFromXML: false,
          });
          applyEngravingPreferences();
          logToFlutter('Loading XMLâ€¦');
          await osmd.load(xmlString);
          logToFlutter(`Loaded sheet: measures=${osmd.sheet?.SourceMeasures?.length ?? 'unknown'}`);
          osmd.zoom = BASE_ZOOM;
          applyEngravingPreferences();
          await osmd.render();
          logToFlutter('Render complete');

          const container = document.getElementById('osmd');
          let widthLabel = null;
          let heightLabel = null;
          let svgMarkup = null;
          if (container) {
            container.style.minHeight = '0';
            container.style.height = 'auto';
            const svg = container.querySelector('svg');
            if (svg) {
              const box = getContentBox(svg);
              const width = box.width;
              const height = box.height;
              makeSvgResponsive(svg, width, height);
              const numericHeight = typeof height === 'number' ? height : Number(height) || 0;
              container.style.minHeight = `${Math.max(numericHeight, 140)}px`;
              widthLabel = typeof width === 'number' ? width.toFixed(2) : width;
              heightLabel = typeof height === 'number' ? height.toFixed(2) : height;
              svgMarkup = svg.outerHTML;
              logToFlutter(`SVG ready width=${widthLabel}, height=${heightLabel}`);
            } else {
              logToFlutter('SVG element missing after render');
            }
          } else {
            logToFlutter('Container missing after render');
          }

          tintHighlightedStems();
          logToFlutter('Highlights applied');
          postToFlutter({ type: 'rendered', width: widthLabel, height: heightLabel, svg: svgMarkup });
          postToFlutter('ready');
        } catch (err) {
          console.error('OSMD load/render failed', err);
          postToFlutter({ type: 'error', phase: 'render', detail: stringifyError(err) });
        }
      }

      function handleMessage(event) {
        if (!event || !event.data) {
          return;
        }

        let message;
        try {
          message = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
        } catch (err) {
          console.error('Unable to parse message', err);
          postToFlutter({ type: 'error', phase: 'parse', detail: stringifyError(err) });
          return;
        }

        if (message?.type === 'init' && message.xml) {
          initOSMD(message);
        }
      }

      window.addEventListener('message', handleMessage);
      window.handleFlutterMessage = handleMessage;
      logToFlutter('OSMD bridge initialised');
    </script>
  </body>
</html>
