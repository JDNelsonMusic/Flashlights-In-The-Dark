
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
    />
    <title>OSMD Practice View</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background-color: #f1f3f6;
        overflow: hidden;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      }

      #osmd {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        background-color: #f1f3f6;
        border-radius: 12px;
        box-sizing: border-box;
        padding: 12px;
      }

      #osmd svg {
        width: auto !important;
        height: auto !important;
        max-width: 100% !important;
        max-height: 100% !important;
      }

      #osmd canvas {
        width: auto !important;
        height: auto !important;
        max-width: 100% !important;
        max-height: 100% !important;
      }

      #osmd svg * {
        fill: #000000 !important;
        stroke: #000000 !important;
      }

      #osmd svg text {
        fill: #000000 !important;
      }

      #osmd svg [fill="none"] {
        stroke: #000000 !important;
      }

      #osmd svg [stroke="none"] {
        fill: #000000 !important;
      }

      #osmd svg [style*="#0C7F79"],
      #osmd svg [style*="#0c7f79"],
      #osmd svg [fill="#0C7F79"],
      #osmd svg [fill="#0c7f79"],
      #osmd svg [data-primer-highlight="true"] {
        fill: #0C7F79 !important;
        stroke: #95FFE3 !important;
        filter:
          drop-shadow(0 0 4px rgba(149, 255, 227, 0.75))
          drop-shadow(0 0 9px rgba(111, 255, 211, 0.45));
      }
    </style>
    <script src="opensheetmusicdisplay.min.js"></script>
  </head>
  <body>
    <div id="osmd" class="osmd-auto-width"></div>
    <script>
      let osmd;
      let activeInitChunks = null;
      let cachedBaseXml = null;
      let cachedBaseContext = null;
      let pendingHighlightRequest = null;
      let latestContextSequence = -1;
      let renderToken = 0;

      const DEFAULT_NOTE_COLOR = '#000000';
      const HIGHLIGHT_NOTE_COLOR = '#0C7F79';
      const HIGHLIGHT_DATA_ATTRIBUTE = 'data-primer-highlight';

      function normalizeContext(value) {
        const parsed = Number(value);
        return Number.isFinite(parsed) ? parsed : null;
      }

      function shouldIgnoreContext(context) {
        if (context === null || context === undefined) {
          return false;
        }
        return context < latestContextSequence;
      }

      function noteContext(context) {
        if (context === null || context === undefined) {
          return;
        }
        if (context > latestContextSequence) {
          latestContextSequence = context;
        }
      }

      function normaliseInitId(rawId) {
        if (rawId === null || rawId === undefined) {
          return null;
        }
        return String(rawId);
      }

      function resetInitChunks(rawId, rawContext) {
        const id = normaliseInitId(rawId);
        const context = normalizeContext(rawContext);
        if (shouldIgnoreContext(context)) {
          return;
        }
        noteContext(context);
        if (!id) {
          activeInitChunks = null;
          return;
        }
        activeInitChunks = { id, total: null, chunks: [], context };
      }

      function ensureInitState(rawId, rawContext) {
        const id = normaliseInitId(rawId);
        const context = normalizeContext(rawContext);
        if (!id) {
          return null;
        }
        if (shouldIgnoreContext(context)) {
          return null;
        }
        noteContext(context);
        if (!activeInitChunks || activeInitChunks.id !== id) {
          activeInitChunks = { id, total: null, chunks: [], context };
        } else if (context !== null) {
          activeInitChunks.context = context;
        }
        return activeInitChunks;
      }

      function handleInitChunk(message) {
        const state = ensureInitState(message?.id, message?.context);
        if (!state) {
          return;
        }
        const context = state.context ?? normalizeContext(message?.context);
        if (shouldIgnoreContext(context)) {
          return;
        }
        const index = Number(message.index);
        const chunk = typeof message.chunk === 'string' ? message.chunk : null;
        if (!Number.isFinite(index) || index < 0 || !chunk) {
          return;
        }
        const total = Number(message.total);
        if (Number.isFinite(total) && total > 0) {
          if (!state.total || total > state.total) {
            const previous = Array.isArray(state.chunks) ? state.chunks.slice() : [];
            state.total = total;
            state.chunks = new Array(total);
            for (let i = 0; i < previous.length && i < total; i += 1) {
              state.chunks[i] = previous[i];
            }
          }
        }
        if (!Array.isArray(state.chunks) || !state.chunks.length) {
          state.chunks = [];
        }
        state.chunks[index] = chunk;
      }

      function finaliseInitChunks(rawId, rawContext) {
        const current = normaliseInitId(rawId) ?? (activeInitChunks ? activeInitChunks.id : null);
        if (!current || !activeInitChunks || activeInitChunks.id !== current) {
          return;
        }
        const state = activeInitChunks;
        const context = state.context ?? normalizeContext(rawContext);
        if (shouldIgnoreContext(context)) {
          return;
        }
        if (context !== null) {
          state.context = context;
          noteContext(context);
        }
        const total = Number(state.total ?? (Array.isArray(state.chunks) ? state.chunks.length : 0));
        if (!Number.isFinite(total) || total <= 0) {
          return;
        }
        if (!Array.isArray(state.chunks) || state.chunks.length < total) {
          postToFlutter({ type: 'error', phase: 'chunk', detail: `OSMD chunk buffer incomplete (${state.chunks?.length || 0}/${total})` });
          return;
        }
        for (let i = 0; i < total; i += 1) {
          if (typeof state.chunks[i] !== 'string') {
            console.warn('OSMD init chunk missing', i, 'of', total);
            postToFlutter({ type: 'error', phase: 'chunk', detail: `Missing OSMD init chunk ${i} of ${total}` });
            return;
          }
        }
        const xml = state.chunks.join('');
        activeInitChunks = null;
        cachedBaseXml = xml;
        cachedBaseContext = state.context ?? latestContextSequence;
        maybeRenderHighlight();
      }

      function maybeRenderHighlight() {
        if (!cachedBaseXml) {
          return;
        }
        let request = null;
        if (pendingHighlightRequest) {
          request = { ...pendingHighlightRequest };
          if (request.context === null || request.context === undefined) {
            request.context = cachedBaseContext ?? latestContextSequence;
          }
        } else {
          request = { context: cachedBaseContext ?? latestContextSequence, measure: null, note: null };
        }
        if (request && request.context !== null && cachedBaseContext !== null && request.context !== cachedBaseContext) {
          return;
        }
        renderHighlightFromCache(request);
      }

      async function renderHighlightFromCache(request) {
        if (!cachedBaseXml) {
          return;
        }
        const effectiveRequest = request || { context: cachedBaseContext ?? latestContextSequence, measure: null, note: null };
        const xml = buildXmlForHighlight(cachedBaseXml, effectiveRequest);
        if (!xml) {
          return;
        }
        const token = ++renderToken;
        try {
          await initOSMD(xml);
        } catch (err) {
          console.error('OSMD highlight render failed', err);
          postToFlutter({ type: 'error', phase: 'highlight-render', detail: String(err && err.stack ? err.stack : err) });
        } finally {
          if (token !== renderToken) {
            return;
          }
        }
      }

      function buildXmlForHighlight(baseXml, request) {
        if (!baseXml) {
          return null;
        }
        const noteLabel = typeof request?.note === 'string' ? request.note.trim() : '';
        const measureValue = Number(request?.measure);
        const measureNumber = Number.isFinite(measureValue) && measureValue > 0 ? measureValue : null;
        if (!noteLabel) {
          return baseXml;
        }
        if (!measureNumber) {
          return baseXml;
        }
        const parsedPitch = parseNoteLabel(noteLabel);
        if (!parsedPitch) {
          return baseXml;
        }
        try {
          const parser = new DOMParser();
          const document = parser.parseFromString(baseXml, 'application/xml');
          const parserIssues = document.getElementsByTagName('parsererror');
          if (parserIssues && parserIssues.length > 0) {
            console.warn('OSMD highlight xml parse error');
            return baseXml;
          }
          applyPrimerHighlight(document, measureNumber, parsedPitch);
          const serializer = new XMLSerializer();
          return serializer.serializeToString(document);
        } catch (err) {
          console.error('OSMD highlight xml build failed', err);
          return baseXml;
        }
      }

      function parseNoteLabel(raw) {
        if (!raw || typeof raw !== 'string') {
          return null;
        }
        const match = /^([A-Ga-g])(bb|##|b|#)?(\d+)$/.exec(raw.trim());
        if (!match) {
          return null;
        }
        const step = match[1].toUpperCase();
        const accidental = match[2] || null;
        const octave = Number(match[3]);
        if (!Number.isFinite(octave)) {
          return null;
        }
        const alter = alterFromAccidental(accidental);
        return { step, alter, octave };
      }

      function alterFromAccidental(accidental) {
        switch (accidental) {
          case 'bb':
            return -2;
          case 'b':
            return -1;
          case '#':
            return 1;
          case '##':
            return 2;
          default:
            return 0;
        }
      }

      function parseMeasureNumber(raw) {
        if (!raw || typeof raw !== 'string') {
          return null;
        }
        const match = /^(\d+)/.exec(raw.trim());
        if (!match) {
          return null;
        }
        const value = Number(match[1]);
        return Number.isFinite(value) ? value : null;
      }

      function extractPitch(noteElement) {
        if (!noteElement) {
          return null;
        }
        const pitchElement = noteElement.querySelector('pitch');
        if (!pitchElement) {
          return null;
        }
        const stepNode = pitchElement.querySelector('step');
        const octaveNode = pitchElement.querySelector('octave');
        if (!stepNode || !octaveNode) {
          return null;
        }
        const step = stepNode.textContent ? stepNode.textContent.trim().toUpperCase() : null;
        const octaveValue = octaveNode.textContent ? Number(octaveNode.textContent.trim()) : null;
        if (!step || !Number.isFinite(octaveValue)) {
          return null;
        }
        const alterNode = pitchElement.querySelector('alter');
        const alterValue = alterNode && alterNode.textContent ? Number(alterNode.textContent.trim()) : 0;
        return {
          step,
          alter: Number.isFinite(alterValue) ? alterValue : 0,
          octave: octaveValue,
        };
      }

      function noteMatchesPitch(noteElement, target) {
        if (!noteElement || !target) {
          return false;
        }
        const parsed = extractPitch(noteElement);
        if (!parsed) {
          return false;
        }
        return parsed.step === target.step && parsed.alter === target.alter && parsed.octave === target.octave;
      }

      function applyPrimerHighlight(document, measureNumber, pitch) {
        if (!document || !pitch || !Number.isFinite(measureNumber)) {
          return;
        }
        const parts = document.getElementsByTagName('part');
        for (let p = 0; p < parts.length; p += 1) {
          const measures = parts[p].getElementsByTagName('measure');
          for (let m = 0; m < measures.length; m += 1) {
            const measure = measures[m];
            const parsedNumber = parseMeasureNumber(measure.getAttribute('number'));
            if (parsedNumber === null || parsedNumber !== measureNumber) {
              continue;
            }
            const notes = measure.getElementsByTagName('note');
            for (let n = 0; n < notes.length; n += 1) {
              const noteElement = notes[n];
              if (noteMatchesPitch(noteElement, pitch)) {
                setNoteHighlight(noteElement, true);
              }
            }
          }
        }
      }

      function setNoteHighlight(noteElement, isHighlighted) {
        if (!noteElement) {
          return;
        }
        if (noteElement.querySelector('rest')) {
          removeHighlightAttributes(noteElement);
          return;
        }
        const targetColor = isHighlighted ? HIGHLIGHT_NOTE_COLOR : DEFAULT_NOTE_COLOR;
        noteElement.setAttribute('color', targetColor);
        removeHighlightAttributes(noteElement);
        if (isHighlighted) {
          noteElement.setAttribute(HIGHLIGHT_DATA_ATTRIBUTE, 'true');
        }
      }

      function removeHighlightAttributes(noteElement) {
        if (!noteElement) {
          return;
        }
        noteElement.removeAttribute(HIGHLIGHT_DATA_ATTRIBUTE);
      }

      function postToFlutter(message) {
        try {
          const payload = typeof message === 'string' ? message : JSON.stringify(message);
          if (window.FlutterOSMD && window.FlutterOSMD.postMessage) {
            window.FlutterOSMD.postMessage(payload);
          }
        } catch (err) {
          console.error('postToFlutter failed', err);
        }
      }

      function countSystems(svg) {
        if (!svg) {
          return 0;
        }
        const systems = svg.querySelectorAll('g.system');
        if (systems.length > 0) {
          return systems.length;
        }
        return svg.querySelectorAll('g[id^="System"]').length;
      }

      function getContentBox(element) {
        try {
          const box = element.getBBox();
          if (box && Number.isFinite(box.width) && box.width > 0 && Number.isFinite(box.height) && box.height > 0) {
            return { width: box.width, height: box.height };
          }
        } catch (_) {}
        const rect = element.getBoundingClientRect();
        return {
          width: rect?.width && rect.width > 0 ? rect.width : 1200,
          height: rect?.height && rect.height > 0 ? rect.height : 320,
        };
      }

      function makeSvgResponsive(svg, width, height) {
        if (!width || !height) {
          return;
        }
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        svg.removeAttribute('width');
        svg.removeAttribute('height');
        svg.style.width = '100%';
        svg.style.height = 'auto';
      }

      function applySingleLineRules() {
        if (!osmd || !osmd.EngravingRules) {
          return;
        }
        const rules = osmd.EngravingRules;
        rules.RenderSingleHorizontalLine = true;
        if (Object.prototype.hasOwnProperty.call(rules, 'RenderSingleHorizontalStaffline')) {
          rules.RenderSingleHorizontalStaffline = true;
        }
        if (Object.prototype.hasOwnProperty.call(rules, 'RenderXMeasuresPerLineAkaSystem')) {
          rules.RenderXMeasuresPerLineAkaSystem = 3;
        }
        if (Object.prototype.hasOwnProperty.call(rules, 'LastSystemMaxScalingFactor')) {
          rules.LastSystemMaxScalingFactor = 1;
        }
        if (Object.prototype.hasOwnProperty.call(rules, 'NewSystemFromXML')) {
          rules.NewSystemFromXML = false;
        }
        if (Object.prototype.hasOwnProperty.call(rules, 'PageWidth')) {
          rules.PageWidth = 4200;
        }
        if (Object.prototype.hasOwnProperty.call(rules, 'PageLeftMargin')) {
          rules.PageLeftMargin = 0;
        }
        if (Object.prototype.hasOwnProperty.call(rules, 'PageRightMargin')) {
          rules.PageRightMargin = 0;
        }
      }

      window.onerror = function(message, source, lineno, colno, error) {
        postToFlutter({ type: 'error', message, source, lineno, colno, detail: error ? String(error.stack || error) : null });
      };

      async function initOSMD(xmlString) {
        activeInitChunks = null;
        if (typeof opensheetmusicdisplay === 'undefined') {
          postToFlutter({ type: 'error', phase: 'init', detail: 'opensheetmusicdisplay bundle unavailable' });
          return;
        }
        if (!osmd) {
          try {
            osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay('osmd', {
              backend: 'svg',
              autoResize: false,
              drawTitle: false,
              drawSubtitle: false,
              drawPartNames: false,
              drawingParameters: 'compacttight',
              renderSingleHorizontalLine: true,
              newSystemFromXML: false,
            });
          } catch (err) {
            console.error('OSMD ctor failed', err);
            postToFlutter({ type: 'error', phase: 'ctor', detail: String(err && err.stack ? err.stack : err) });
            return;
          }
        }

        try {
          await osmd.load(xmlString);
          applySingleLineRules();
          osmd.zoom = 0.6;
          await renderWindow(1);
          postToFlutter('ready');
        } catch (err) {
          console.error('OSMD load failed', err);
          postToFlutter({ type: 'error', phase: 'load', detail: String(err && err.stack ? err.stack : err) });
        }
      }

      async function renderWindow(measureNumber) {
        if (!osmd) {
          return;
        }
        try {
          let from = Math.max(1, measureNumber - 1);
          let to = measureNumber + 1;
          if (to - from < 2) {
            to = from + 2;
          }
          if (osmd.sheet && osmd.sheet.SourceMeasures && osmd.sheet.SourceMeasures.length) {
            const maxMeasure = osmd.sheet.SourceMeasures.length;
            if (to > maxMeasure) {
              to = maxMeasure;
              from = Math.max(1, to - 2);
            }
          }

          let zoom = 0.6;
          for (let attempt = 0; attempt < 6; attempt += 1) {
            osmd.setOptions({
              drawFromMeasureNumber: from,
              drawUpToMeasureNumber: to,
              renderSingleHorizontalLine: true,
              newSystemFromXML: false,
            });
            osmd.zoom = zoom;
            applySingleLineRules();
            await osmd.render();

            const container = document.getElementById('osmd');
            const svg = container ? container.querySelector('svg') : null;
            const systems = countSystems(svg);
            if (svg) {
              const box = getContentBox(svg);
              makeSvgResponsive(svg, box.width, box.height);
              container.style.minHeight = `${Math.max(box.height, 140)}px`;
            }

            if (systems <= 1) {
              break;
            }

            zoom *= 0.85;
          }

          postToFlutter({ type: 'window-rendered', from, to });
        } catch (err) {
          console.error('OSMD render failed', err);
          postToFlutter({ type: 'error', phase: 'render', detail: String(err && err.stack ? err.stack : err) });
        }
      }

      function handleHighlightMessage(message) {
        const context = normalizeContext(message?.context);
        if (shouldIgnoreContext(context)) {
          return;
        }
        if (context !== null) {
          noteContext(context);
        }
        const measureValue = Number(message?.measure);
        const noteRaw = typeof message?.note === 'string' ? message.note.trim() : null;
        pendingHighlightRequest = {
          context: context ?? latestContextSequence,
          measure: Number.isFinite(measureValue) && measureValue > 0 ? measureValue : null,
          note: noteRaw && noteRaw.length ? noteRaw : null,
        };
        maybeRenderHighlight();
      }

      function handleMessage(event) {
        if (!event || !event.data) {
          return;
        }

        let message;
        try {
          message = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
        } catch (err) {
          console.error('Unable to parse message', err);
          return;
        }

        if (message?.type === 'init' && message.xml) {
          const context = normalizeContext(message.context);
          if (shouldIgnoreContext(context)) {
            return;
          }
          noteContext(context);
          cachedBaseXml = message.xml;
          cachedBaseContext = context ?? latestContextSequence;
          activeInitChunks = null;
          maybeRenderHighlight();
        } else if (message?.type === 'window' && typeof message.measure === 'number') {
          renderWindow(message.measure);
        } else if (message?.type === 'init-reset') {
          resetInitChunks(message.id, message.context);
        } else if (message?.type === 'init-chunk') {
          handleInitChunk(message);
        } else if (message?.type === 'init-chunk-final') {
          finaliseInitChunks(message.id, message.context);
        } else if (message?.type === 'highlight') {
          handleHighlightMessage(message);
        }
      }

      window.addEventListener('message', handleMessage);
      window.handleFlutterMessage = handleMessage;
    </script>
  </body>
</html>
